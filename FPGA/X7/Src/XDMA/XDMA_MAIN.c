/* $Id: */
/*******************************************************************************
** © Copyright 2012 Xilinx, Inc. All rights reserved.
** This file contains confidential and proprietary information of Xilinx, Inc. and 
** is protected under U.S. and international copyright and other intellectual property laws.
*******************************************************************************
**   ____  ____ 
**  /   /\/   / 
** /___/  \  /   Vendor: Xilinx 
** \   \   \/    
**  \   \        
**  /   /          
** /___/   /\     
** \   \  /  \
**  \___\/\___\ 
** 
*******************************************************************************
**
**  Disclaimer: 
**
**    This disclaimer is not a license and does not grant any rights to the materials 
**    distributed herewith. Except as otherwise provided in a valid license issued to you 
**    by Xilinx, and to the maximum extent permitted by applicable law: 
**    (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, 
**    AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, 
**    INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, OR 
**    FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable (whether in contract 
**    or tort, including negligence, or under any other theory of liability) for any loss or damage 
**    of any kind or nature related to, arising under or in connection with these materials, 
**    including for any direct, or any indirect, special, incidental, or consequential loss 
**    or damage (including loss of data, profits, goodwill, or any type of loss or damage suffered 
**    as a result of any action brought by a third party) even if such damage or loss was 
**    reasonably foreseeable or Xilinx had been advised of the possibility of the same.
**
**  Critical Applications:
**
**    Xilinx products are not designed or intended to be fail-safe, or for use in any application 
**    requiring fail-safe performance, such as life-support or safety devices or systems, 
**    Class III medical devices, nuclear facilities, applications related to the deployment of airbags,
**    or any other applications that could lead to death, personal injury, or severe property or 
**    environmental damage (individually and collectively, "Critical Applications"). Customer assumes 
**    the sole risk and liability of any use of Xilinx products in Critical Applications, subject only 
**    to applicable laws and regulations governing limitations on product liability.
**
**  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT ALL TIMES.
**
*******************************************************************************/
/*++

Module Name:

	XDMA_MAIN.c

Abstract:

    This is main WDF driver interface. It contains most of the operating system or
    WDF required functions for a driver. It all starts with Driver_Entry below.

Environment:

    Kernel mode

--*/

#include "precomp.h"

#if TRACE_ENABLED
//
// The trace message header (.tmh) file must be included in a source file
// before any WPP macro calls and after defining a WPP_CONTROL_GUIDS
// macro. During the compilation, WPP scans the source files for TraceEvents()
// calls and builds a .tmh file which stores a unique data GUID for each 
// message, the text resource string for each message, and the data types 
// of the variables passed in for each message.  This file is automatically 
// generated by the WPP preprocessor.
//
#include "XDMA_MAIN.tmh"
#endif // TRACE_ENABLED


// Windows XP component IDs for DbgPrintEx are different than later
//  Windows version.  We have to query the OS on start up and adjust the 
//   component ID if necessary.
ULONG	DbgComponentID	=	DPFLTR_IHVDRIVER_ID;

/*++

Routine Description:

    Driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    NTSTATUS    - if the status value is not STATUS_SUCCESS,
                        the driver will get unloaded immediately.

--*/
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    WDF_DRIVER_CONFIG   config;
    WDF_OBJECT_ATTRIBUTES attributes;

#if TRACE_ENABLED
    // Initialize WDF WPP tracing.
    WPP_INIT_TRACING( DriverObject, RegistryPath );
#else
	RTL_OSVERSIONINFOEXW osver;
	
	osver.dwOSVersionInfoSize = sizeof(osver);
	RtlGetVersion((PRTL_OSVERSIONINFOW)&osver);
	if ((osver.dwMajorVersion == 5) && (osver.dwMinorVersion == 1))
	{
		// Adjust the ID for Windows XP.
		DbgComponentID = DPFLTR_IHVDRIVER_ID+2;	
	}
#endif // TRACE_ENABLED

	DEBUGP(DEBUG_ALWAYS, "Xilinx XDMA Driver: Built %s %s", __DATE__, __TIME__);

    // Initialize the Driver Config structure.
    WDF_DRIVER_CONFIG_INIT( &config, XlxEvtDeviceAdd );

    // Register a cleanup callback so that we can call WPP_CLEANUP when
    // the framework driver object is deleted during driver unload.
    WDF_OBJECT_ATTRIBUTES_INIT(&attributes);
    attributes.EvtCleanupCallback = XlxEvtDriverContextCleanup;

    status = WdfDriverCreate( DriverObject,
                              RegistryPath,
                              &attributes,
                              &config,
                              WDF_NO_HANDLE);
    if (!NT_SUCCESS(status)) {
		DEBUGP(DEBUG_ERROR, "WdfDriverCreate failed with status 0x%x", status);

#if TRACE_ENABLED
        // Cleanup tracing here because DriverContextCleanup will not be called
        // as we have failed to create WDFDRIVER object itself.
        WPP_CLEANUP(DriverObject);
#endif // TRACE_ENABLED
    }
    return status;
}


/*++

Routine Description:

    EvtDeviceAdd is called by the framework in response to AddDevice
    call from the PnP manager. Here the driver should register all the
    PNP, power and Io callbacks, register interfaces and allocate other
    software resources required by the device. The driver can query
    any interfaces or get the config space information from the bus driver
    but cannot access hardware registers or initialize the device.

Arguments:
 
    Driver - WDFDRIVER Unused.        
    DeviceInit - PWDFDEVICE_INIT  
 
Return Value:

--*/
NTSTATUS
XlxEvtDeviceAdd(
    IN WDFDRIVER        Driver,
    IN PWDFDEVICE_INIT  DeviceInit
    )
{
    NTSTATUS                   status = STATUS_SUCCESS;
    WDF_PNPPOWER_EVENT_CALLBACKS pnpPowerCallbacks;
	WDF_DEVICE_POWER_CAPABILITIES powerCaps;
    WDF_OBJECT_ATTRIBUTES       attributes;
    WDFDEVICE                   device;
    PDEVICE_EXTENSION           pDevExt = NULL;

    UNREFERENCED_PARAMETER( Driver );

	DEBUGP(DEBUG_ALWAYS, "--> XlxEvtDeviceAdd");

   // PAGED_CODE();

    // Set to direct I/O, we do not want the OS doing a double copy on our behalf.
    WdfDeviceInitSetIoType(DeviceInit, WdfDeviceIoDirect);

    // Zero out the PnpPowerCallbacks structure.
    WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);

    // Set Callbacks for any of the functions we are interested in.
    // If no callback is set, Framework will take the default action
    // by itself.
    pnpPowerCallbacks.EvtDevicePrepareHardware = XlxEvtDevicePrepareHardware;
    pnpPowerCallbacks.EvtDeviceReleaseHardware = XlxEvtDeviceReleaseHardware;

    // These two callbacks set up and tear down hardware state that must be
    // done every time the device moves in and out of the D0-working state.
    pnpPowerCallbacks.EvtDeviceD0Entry         = XlxEvtDeviceD0Entry;
    pnpPowerCallbacks.EvtDeviceD0Exit          = XlxEvtDeviceD0Exit;

    // Register the PnP Callbacks..
    WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);

    // Initialize Fdo Attributes.
    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&attributes, DEVICE_EXTENSION);

    // Set SynchronizationScopeDevice, we tell the framework to
    // synchronize callbacks events of all the objects directly associated
    // with the device. In this driver, we will associate queues. By doing 
    // that we don't have to worry about synchronizing access to device
    // context by Io Events because they would not concurrently ever. 
    // Framework will serialize them by using an internal device-lock.
    attributes.SynchronizationScope = WdfSynchronizationScopeDevice;

    // Create the device
    status = WdfDeviceCreate( &DeviceInit, &attributes, &device );

    if (!NT_SUCCESS(status)) {
        // Device Initialization failed.
		DEBUGP(DEBUG_ERROR, "DeviceCreate failed 0x%x", status);
        return status;
    }
	
	// Zero out the Power Capabilities structure.
	WDF_DEVICE_POWER_CAPABILITIES_INIT(&powerCaps);

	powerCaps.DeviceD1 =   WdfTrue;
	powerCaps.DeviceD2 =   WdfFalse;

	powerCaps.WakeFromD0 = WdfTrue;
    powerCaps.WakeFromD1 = WdfTrue;
	powerCaps.WakeFromD2 = WdfFalse;
	powerCaps.WakeFromD3 = WdfFalse;

    powerCaps.DeviceWake = PowerDeviceD1;

    powerCaps.DeviceState[PowerSystemWorking] =   PowerDeviceD0;
    powerCaps.DeviceState[PowerSystemSleeping1] = PowerDeviceD1;
    powerCaps.DeviceState[PowerSystemSleeping2] = PowerDeviceD1;
    powerCaps.DeviceState[PowerSystemSleeping3] = PowerDeviceD1;
    powerCaps.DeviceState[PowerSystemHibernate] = PowerDeviceD1;
    powerCaps.DeviceState[PowerSystemShutdown] =  PowerDeviceD1;

	powerCaps.IdealDxStateForSx                =  PowerDeviceD1;

	//Set Power Capabilities to Device
	WdfDeviceSetPowerCapabilities(device,&powerCaps);

    // Get the DeviceExtension and initialize it. XlxGetDeviceContext is an inline function
    // defined by WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in the private header file. 
    pDevExt = XlxGetDeviceContext(device);
    pDevExt->Device = device;

	DEBUGP(DEBUG_INFO, "     AddDevice PDO (0x%p) FDO (0x%p), DevExt (0x%p)",
                WdfDeviceWdmGetPhysicalDevice(device),
                WdfDeviceWdmGetDeviceObject(device), pDevExt);

    // Tell the Framework that this device will need an interface
    // NOTE: See the note in Public.h concerning this GUID value.
    status = WdfDeviceCreateDeviceInterface( device,
                                             (LPGUID) &GUID_V7_XDMA_INTERFACE,
                                             NULL );
    if (!NT_SUCCESS(status)) {
		DEBUGP(DEBUG_ERROR, "WdfDeviceCreateDeviceInterface failed 0x%x", status);
        return status;
    }

    // Initalize the Device Extension, there is one Device Extension (DevExt) per adapter.
    status = XlxInitializeDeviceExtension(pDevExt);
    if (!NT_SUCCESS(status)) {
		DEBUGP(DEBUG_ERROR, "XlxInitializeDeviceExtension failed 0x%x", status);
        return status;
    }

    // Create the Driver To Driver linkage support
    status =  XlxCreateDriverToDriverInterface(pDevExt);
    if (!NT_SUCCESS(status)) {
		DEBUGP(DEBUG_ERROR, "XlxCreateDriverToDriverInterface failed 0x%x", status);
        return status;
    }
#if 1
	// Now hook up the interrupt.
	status = XlxInterruptCreate(pDevExt);
    if (!NT_SUCCESS(status)) 
	{
	    return status;
	}
#endif

    return status;
}

/*++

Routine Description:

    Performs whatever initialization is needed to setup the device, setting up
    a DMA channel or mapping any I/O port resources.  This will only be called
    as a device starts or restarts, not every time the device moves into the D0
    state.  Consequently, most hardware initialization belongs elsewhere.

Arguments:

    Device - A handle to the WDFDEVICE

    Resources - The raw PnP resources associated with the device.  

    ResourcesTranslated - The translated PnP resources associated with the
        device. 

Return Value:

    NT status code - failure will result in the device stack being torn down

--*/
NTSTATUS
XlxEvtDevicePrepareHardware (
    WDFDEVICE       Device,
    WDFCMRESLIST    Resources,
    WDFCMRESLIST    ResourcesTranslated
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   pDevExt;

    UNREFERENCED_PARAMETER(Resources);

  //  PAGED_CODE();

	DEBUGP(DEBUG_ALWAYS, "--> XlxEvtDevicePrepareHardware");

    pDevExt = XlxGetDeviceContext(Device);

    // Now do our hardware specific initialization
    status = XlxPrepareHardware(pDevExt, ResourcesTranslated);
    if (!NT_SUCCESS (status)){
        return status;
    }

	DEBUGP(DEBUG_TRACE, "<-- XlxEvtDevicePrepareHardware, status 0x%x", status);
    return status;
}


/*++

Routine Description:

    Unmap the resources that were mapped in XlxEvtDevicePrepareHardware.
    This will only be called when the device stopped for resource rebalance,
    surprise-removed or query-removed.

Arguments:

    Device - A handle to the WDFDEVICE

    ResourcesTranslated - The translated PnP resources associated with the
        device.  This is what is important to a PCI device.

Return Value:

    NT status code - failure will result in the device stack being torn down

--*/
NTSTATUS
XlxEvtDeviceReleaseHardware(
    IN  WDFDEVICE Device,
    IN  WDFCMRESLIST ResourcesTranslated
    )
{
    PDEVICE_EXTENSION   pDevExt;
    NTSTATUS            status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(ResourcesTranslated);

    //PAGED_CODE();

	DEBUGP(DEBUG_ALWAYS, "--> XlxEvtDeviceReleaseHardware");

    pDevExt = XlxGetDeviceContext(Device);
    // Now do our hardware specific cleanup
    status = XlxReleaseHardware(pDevExt);

	DEBUGP(DEBUG_TRACE, "<-- XlxEvtDeviceReleaseHardware");
    return status;
}


/*++

Routine Description:

    This routine prepares the device for use.  It is called whenever the device
    enters the D0 state, which happens when the device is started, when it is
    restarted, and when it has been powered off.

    Note that interrupts will not be enabled at the time that this is called.
    They will be enabled after this callback completes.

    This function is not marked pageable because this function is in the
    device power up path. When a function is marked pagable and the code
    section is paged out, it will generate a page fault which could impact
    the fast resume behavior because the client driver will have to wait
    until the system drivers can service this page fault.

Arguments:

    Device  - The handle to the WDF device object

    PreviousState - The state the device was in before this callback was invoked.

Return Value:

    NTSTATUS

    Success implies that the device can be used.

    Failure will result in the    device stack being torn down.

--*/
NTSTATUS
XlxEvtDeviceD0Entry(
    IN  WDFDEVICE Device,
    IN  WDF_POWER_DEVICE_STATE PreviousState
    )
{
    PDEVICE_EXTENSION   pDevExt;
    NTSTATUS            status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(PreviousState);
	DEBUGP(DEBUG_ALWAYS, "--> XlxEvtDeviceD0Entry");
    pDevExt = XlxGetDeviceContext(Device);

    // Do power management initialization functions
    XlxD0Startup(pDevExt);
	DEBUGP(DEBUG_TRACE, "<-- XlxEvtDeviceD0Entry");
    return status;
}


/*++

Routine Description:

    This routine undoes anything done in XlxEvtDeviceD0Entry.  It is called
    whenever the device leaves the D0 state, which happens when the device
    is stopped, when it is removed, and when it is powered off.

    The device is still in D0 when this callback is invoked, which means that
    the driver can still touch hardware in this routine.

    Note that interrupts have already been disabled by the time that this
    callback is invoked.

Arguments:

    Device  - The handle to the WDF device object

    TargetState - The state the device will go to when this callback completes.

Return Value:

    Success implies that the device can be used.  Failure will result in the
    device stack being torn down.

--*/
NTSTATUS
XlxEvtDeviceD0Exit(
    IN  WDFDEVICE Device,
    IN  WDF_POWER_DEVICE_STATE TargetState
    )
{
    PDEVICE_EXTENSION   pDevExt;

   // PAGED_CODE();

	UNREFERENCED_PARAMETER(TargetState);

    pDevExt = XlxGetDeviceContext(Device);

	DEBUGP(DEBUG_ALWAYS, "XlxEvtDeviceD0Exit: enter, TargetState:0x%x", TargetState);

	XlxD0Shutdown(pDevExt);

    return STATUS_SUCCESS;
}



/*++
Routine Description:

    Free all the resources allocated in DriverEntry.

Arguments:

    Driver - handle to a WDF Driver object.

Return Value:

    VOID.

--*/
VOID
XlxEvtDriverContextCleanup(
    IN WDFDRIVER Driver
    )
{
  //  PAGED_CODE ();
	UNREFERENCED_PARAMETER(Driver);

	DEBUGP(DEBUG_ALWAYS, "XlxEvtDriverContextCleanup: enter");
#if TRACE_ENABLED
    WPP_CLEANUP( WdfDriverWdmGetDriverObject( Driver ) );
#endif // TRACE_ENABLED
	DEBUGP(DEBUG_ALWAYS, "XlxEvtDriverContextCleanup: exit");
}



